// Copyright 2024 Horizon Blockchain Games Inc. All rights reserved.
#include "ABI/ABI.h"
#include "Misc/AutomationTest.h"
#include "Types/BinaryData.h"


IMPLEMENT_SIMPLE_AUTOMATION_TEST(TestABI, "Public.Tests.TestABI",
                                 EAutomationTestFlags::EditorContext | EAutomationTestFlags::EngineFilter)

bool TestABI::RunTest(const FString& Parameters)
{
	// This example encodes a function call to a function with signature g(uint256[][],string[])
	// and values ([[1, 2], [3]], ["one", "two", "three"])

	TFixedABIData Int1 = ABI::UInt32(1);
	TFixedABIData Int2 = ABI::UInt32(2);
	TDynamicABIArray IntArray1;
	IntArray1.Push(MakeShared<ABIElement>(Int1));
	IntArray1.Push(MakeShared<ABIElement>(Int2));

	TFixedABIData Int3 = ABI::UInt32(3);
	TDynamicABIArray IntArray2;
	IntArray2.Push(MakeShared<ABIElement>(Int3));
	
	TDynamicABIArray IntArrayArray;
	IntArrayArray.Push(MakeShared<ABIElement>(IntArray1));
	IntArrayArray.Push(MakeShared<ABIElement>(IntArray2));
	
	TDynamicABIData String1 = ABI::String("one");
	TDynamicABIData String2 = ABI::String("two");
	TDynamicABIData String3 = ABI::String("three");
	TDynamicABIArray StringArray;
	StringArray.Push(MakeShared<ABIElement>(String1));
	StringArray.Push(MakeShared<ABIElement>(String2));
	StringArray.Push(MakeShared<ABIElement>(String3));

	// We push all the arguments in an array
	TArray<ABIElement*> Arr = TArray<ABIElement*>();
	Arr.Push(&IntArrayArray);
	Arr.Push(&StringArray);
	
	UE_LOG(LogTemp, Display, TEXT("%s"), *ABI::Display("g(uint256[][],string[])", Arr));

	auto Encoded = ABI::Encode("g(uint256[][],string[])", Arr).ToHex();

	FString Correct = "2289b18c"
					"0000000000000000000000000000000000000000000000000000000000000040"
					"0000000000000000000000000000000000000000000000000000000000000140"
					"0000000000000000000000000000000000000000000000000000000000000002"
					"0000000000000000000000000000000000000000000000000000000000000040"
					"00000000000000000000000000000000000000000000000000000000000000a0"
					"0000000000000000000000000000000000000000000000000000000000000002"
					"0000000000000000000000000000000000000000000000000000000000000001"
					"0000000000000000000000000000000000000000000000000000000000000002"
					"0000000000000000000000000000000000000000000000000000000000000001"
					"0000000000000000000000000000000000000000000000000000000000000003"
					"0000000000000000000000000000000000000000000000000000000000000003"
					"0000000000000000000000000000000000000000000000000000000000000060"
					"00000000000000000000000000000000000000000000000000000000000000a0"
					"00000000000000000000000000000000000000000000000000000000000000e0"
					"0000000000000000000000000000000000000000000000000000000000000003"
					"6f6e650000000000000000000000000000000000000000000000000000000000"
					"0000000000000000000000000000000000000000000000000000000000000003"
					"74776f0000000000000000000000000000000000000000000000000000000000"
					"0000000000000000000000000000000000000000000000000000000000000005"
					"7468726565000000000000000000000000000000000000000000000000000000";
	
	if(Correct != Encoded)
	{
		return false;
	}
	
	// Make the test pass by returning true, or fail by returning false.
	return true;
}

